**软件工程规范**：主要参考代码整洁之道、代码大全、程序员修炼之道、设计模式(GOF)、设计模式的艺术。

**1 代码整洁之道**

+------------------------------+--------------------+----------------+
| Tags                         | Title              | Notes key word |
+==============================+====================+================+
|                              | 2命名              |                |
+------------------------------+--------------------+----------------+
| 避免误导                     |                    |                |
+------------------------------+--------------------+----------------+
| 做有意义的区分               |                    |                |
+------------------------------+--------------------+----------------+
| 使用可搜索的名称             |                    |                |
+------------------------------+--------------------+----------------+
| 命名时避免使用编码           |                    |                |
+------------------------------+--------------------+----------------+
| 类名、方法名                 |                    |                |
+------------------------------+--------------------+----------------+
| 每个概念用一个词             |                    |                |
+------------------------------+--------------------+----------------+
|                              | 3函数              |                |
+------------------------------+--------------------+----------------+
| 越短小越好                   |                    |                |
+------------------------------+--------------------+----------------+
| 只做一件事                   |                    |                |
+------------------------------+--------------------+----------------+
| 每个函数一个抽象层级         |                    |                |
+------------------------------+--------------------+----------------+
| 使用描述性的名称             |                    |                |
+------------------------------+--------------------+----------------+
| 函数参数                     |                    |                |
+------------------------------+--------------------+----------------+
| #### 副作用(函数在正常工作任 |                    |                |
| 务之外对外部环境所施加的影响 |                    |                |
| ) {#副作用函数在正常工作任务 |                    |                |
| 之外对外部环境所施加的影响}  |                    |                |
+------------------------------+--------------------+----------------+
| 设置(写)和查询(读)分离       |                    |                |
+------------------------------+--------------------+----------------+
| 使用异常代替返回错误码       |                    |                |
+------------------------------+--------------------+----------------+
| 结构化编程                   |                    |                |
+------------------------------+--------------------+----------------+
|                              | 4注释              |                |
+------------------------------+--------------------+----------------+
| 用代码来阐述                 |                    |                |
+------------------------------+--------------------+----------------+
| 好注释                       |                    |                |
+------------------------------+--------------------+----------------+
| 坏注释                       |                    |                |
+------------------------------+--------------------+----------------+
|                              | 5代码格式          |                |
+------------------------------+--------------------+----------------+
| 垂直格式                     |                    |                |
+------------------------------+--------------------+----------------+
| 水平格式                     |                    |                |
+------------------------------+--------------------+----------------+
|                              | 6对象和数据结构    |                |
+------------------------------+--------------------+----------------+
| 对象与数据结构的反对称性     |                    |                |
+------------------------------+--------------------+----------------+
| #                            |                    |                |
| ### Demeter定律(最少知识原则 |                    |                |
| ) {#demeter定律最少知识原则} |                    |                |
+------------------------------+--------------------+----------------+
|                              | 7异常处理          |                |
+------------------------------+--------------------+----------------+
| 使用异常而不是返回错误码     |                    |                |
+------------------------------+--------------------+----------------+
| 根据调用者的需要             |                    |                |
| 定义不同的异常处理类         |                    |                |
+------------------------------+--------------------+----------------+
| 特例模式:                    |                    |                |
| 创建一个类来处理特例         |                    |                |
+------------------------------+--------------------+----------------+
| ####                         |                    |                |
| 别返回null值 {#别返回null值} |                    |                |
+------------------------------+--------------------+----------------+
| 别传递null值                 |                    |                |
+------------------------------+--------------------+----------------+
|                              | 8边界              |                |
+------------------------------+--------------------+----------------+
| 避免公共API返回边界接口      |                    |                |
| ，或者将边界接口作为参数传递 |                    |                |
| 给API。将边界保留在近亲类中  |                    |                |
+------------------------------+--------------------+----------------+
| 不要在生产代码中试验新东西， |                    |                |
| 而是编写测试来理解第三方代码 |                    |                |
|                              |                    |                |
| 避免我们的代码过多           |                    |                |
| 地了解第三方代码中的特定信息 |                    |                |
+------------------------------+--------------------+----------------+
|                              | 9单元测试          |                |
+------------------------------+--------------------+----------------+
| TDD(Test-driven              |                    |                |
| development)三定律           |                    |                |
+------------------------------+--------------------+----------------+
| 保持测试整洁                 |                    |                |
+------------------------------+--------------------+----------------+
| 整洁的测试依赖于FIRST规则    |                    |                |
+------------------------------+--------------------+----------------+
|                              | 10类               |                |
+------------------------------+--------------------+----------------+
| 类的结构组织(顺序)           |                    |                |
+------------------------------+--------------------+----------------+
| 类应该短小                   |                    |                |
|                              |                    |                |
| 单                           |                    |                |
| 一权责原则、许多短小的类、保 |                    |                |
| 持内聚性就会得到许多短小的类 |                    |                |
+------------------------------+--------------------+----------------+
| 为修改而组织                 |                    |                |
+------------------------------+--------------------+----------------+
|                              | 11系统             |                |
+------------------------------+--------------------+----------------+
| 将系统的构造与使用分开       |                    |                |
+------------------------------+--------------------+----------------+
|                              | 12 emergent design |                |
+------------------------------+--------------------+----------------+
| 运行所有测试                 |                    |                |
+------------------------------+--------------------+----------------+
| 消除重复                     |                    |                |
+------------------------------+--------------------+----------------+
| 表达意图                     |                    |                |
+------------------------------+--------------------+----------------+
| #### 尽可能少的类            |                    |                |
| 和方法 {#尽可能少的类和方法} |                    |                |
+------------------------------+--------------------+----------------+
|                              | 13并发编程         |                |
+------------------------------+--------------------+----------------+
| 遵循单一职责原               |                    |                |
| 则。分离并发代码与非并发代码 |                    |                |
+------------------------------+--------------------+----------------+
| 限制临界区                   |                    |                |
| 数量、限制对共享数据的访问。 |                    |                |
+------------------------------+--------------------+----------------+
| 避免使                       |                    |                |
| 用共享数据，使用对象的副本。 |                    |                |
+------------------------------+--------------------+----------------+
| 线程尽可能地                 |                    |                |
| 独立，不与其他线程共享数据。 |                    |                |
+------------------------------+--------------------+----------------+
|                              |                    |                |
+------------------------------+--------------------+----------------+

**2 代码大全**

+----------------------+----------------------+----------------------+
| Tags                 | Title                | Note key word        |
+======================+======================+======================+
|                      | **第一部分           |                      |
|                      | 打好基础**           |                      |
+----------------------+----------------------+----------------------+
| 1欢                  |                      | -                    |
| 迎进入软件构建的世界 |                      | **软件构建**是软件开 |
|                      |                      | 发的**核心**活动；构 |
|                      |                      | 建活动是每个项目中位 |
|                      |                      | 移一项必不可少的工作 |
|                      |                      |                      |
|                      |                      | -   软件构建         |
|                      |                      | 的主要活动包括：详细 |
|                      |                      | 设计、编码、调试、集 |
|                      |                      | 成、开发者测试（包括 |
|                      |                      | 单元测试和集成测试） |
|                      |                      |                      |
|                      |                      | -   构建也           |
|                      |                      | 被称作"编码"和"编程" |
|                      |                      |                      |
|                      |                      | -   构               |
|                      |                      | 建活动的质量对软件的 |
|                      |                      | 质量有着实质性的影响 |
|                      |                      |                      |
|                      |                      | -   最后，**你对     |
|                      |                      | "如何进行构建"的理解 |
|                      |                      | 程度，决定了你这名\" |
|                      |                      | 程序员\"的优秀程度** |
+----------------------+----------------------+----------------------+
| 2用隐喻来            |                      | 隐喻是以一种         |
| 更充分地理解软件开发 |                      | **类比**的方法根据一 |
|                      |                      | 种已知的"模型范式"去 |
|                      |                      | 理解一种**新的领域** |
|                      |                      | 。这很符合人类认知新 |
|                      |                      | 事物的思维习惯。但隐 |
|                      |                      | 喻不是神话，更不是精 |
|                      |                      | 确的真理，就像某个比 |
|                      |                      | 喻一样只能在某一个局 |
|                      |                      | 部进行双向的类比，未 |
|                      |                      | 必就是全局最合适的。 |
+----------------------+----------------------+----------------------+
| 3                    |                      | -   构建活           |
| 三思而后行：前期准备 |                      | 动的准备工作的根本目 |
|                      |                      | 标在于降低风险。要确 |
|                      |                      | 认你的准备活动是在降 |
|                      |                      | 低风险，而非增加风险 |
|                      |                      |                      |
|                      |                      | -   如果你想开       |
|                      |                      | 发高质量的软件，软件 |
|                      |                      | 开发过程必须由始至终 |
|                      |                      | 关注质量。在项目初期 |
|                      |                      | 关注质量，对产品质量 |
|                      |                      | 的正面影响比在项目末 |
|                      |                      | 期关注质量的一项要大 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   程序员的一部分工作 |
|                      |                      | 是教育老板和合作者， |
|                      |                      | 告诉他们软件开发过程 |
|                      |                      | ，包括在开始编程之前 |
|                      |                      | 进行充分准备的重要性 |
|                      |                      |                      |
|                      |                      | -   你所             |
|                      |                      | 从事的软件项目的类型 |
|                      |                      | 对构建活动的前期准备 |
|                      |                      | 有重大影响------许多 |
|                      |                      | 项目应该是高度迭代的 |
|                      |                      | ，某些应该是序列式的 |
|                      |                      |                      |
|                      |                      | -   **如             |
|                      |                      | 果没有明确的问题定义 |
|                      |                      | ，那么你可能会在构建 |
|                      |                      | 期间解决错误的问题** |
|                      |                      |                      |
|                      |                      | -   如果没有做完良   |
|                      |                      | 好的需求分析工作，你 |
|                      |                      | 可能没有察觉待解决的 |
|                      |                      | 问题的重要细节。**如 |
|                      |                      | 果需求变更发生在构建 |
|                      |                      | 之后的阶段，其代价是 |
|                      |                      | "在项目早期更改需求  |
|                      |                      | "的20-100倍**。因此  |
|                      |                      | 在开始编程之前，你要 |
|                      |                      | 确认"需求"已经到位了 |
|                      |                      |                      |
|                      |                      | -   如果没有         |
|                      |                      | 做完良好的架构设计， |
|                      |                      | 你可能会在构建期间用 |
|                      |                      | 错误的方法解决正确的 |
|                      |                      | 问题。架构变更的代价 |
|                      |                      | 随着"为错误的架构编  |
|                      |                      | 写的代码数量"增加而  |
|                      |                      | 增加，因此，也要确认 |
|                      |                      | ""架构""已经到位了。 |
|                      |                      |                      |
|                      |                      | -   理解项目的前期   |
|                      |                      | 准备所采用的方法，并 |
|                      |                      | 相应地选择构建方法。 |
+----------------------+----------------------+----------------------+
| 4关键的『构建』决策  |                      | -   每种             |
|                      |                      | 编程语言都有其优点和 |
|                      |                      | 弱点。要知道你使用的 |
|                      |                      | 语言的明确优点和弱点 |
|                      |                      |                      |
|                      |                      | -   在开始编程之前   |
|                      |                      | ，做好一些约定。"改  |
|                      |                      | 变代码"使之符合这些  |
|                      |                      | "约定"是几乎不可能的 |
|                      |                      |                      |
|                      |                      | -   "构建的          |
|                      |                      | 实践方法"的种类比任  |
|                      |                      | 何单个项目能用到的要 |
|                      |                      | 多。有意识地选择最适 |
|                      |                      | 合你的项目的时间方法 |
|                      |                      |                      |
|                      |                      | -   问问你自己       |
|                      |                      | ，你采用的编程实践是 |
|                      |                      | 对你所用的编程语言的 |
|                      |                      | 正确响应，还是受它的 |
|                      |                      | 控制？清记得"深入一  |
|                      |                      | 种语言去编程"，不要  |
|                      |                      | 仅"在一种语言上编程" |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 你在技术浪潮中的位置 |
|                      |                      | 决定了哪种方法是有效 |
|                      |                      | 的------甚至是可能用 |
|                      |                      | 到的。**确定你在技术 |
|                      |                      | 浪潮中的位置**，并响 |
|                      |                      | 应调整计划和预期目标 |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第2部分            |                      |
|                      | 创建高质量的代码**   |                      |
+----------------------+----------------------+----------------------+
| 5软件构建中的设计    |                      | -                    |
|                      |                      |   **软件的首要技术使 |
|                      |                      | 命就是管理复杂度。以 |
|                      |                      | 简单作为努力目标的设 |
|                      |                      | 计方案对此最有帮助** |
|                      |                      |                      |
|                      |                      | -   简单             |
|                      |                      | 性可以通过两种方式获 |
|                      |                      | 取：一是减少在同一时 |
|                      |                      | 间所关注的本质性复杂 |
|                      |                      | 度的量；而是避免生成 |
|                      |                      | 不必要的偶然的复杂度 |
|                      |                      |                      |
|                      |                      | -   设计是一种启发式 |
|                      |                      | 的过程。固执于某一种 |
|                      |                      | 单一方法会损害创新能 |
|                      |                      | 力，从而损害你的程序 |
|                      |                      |                      |
|                      |                      | -   好的设计都是迭代 |
|                      |                      | 的。你尝试设计的可能 |
|                      |                      | 性越多，你的最终分设 |
|                      |                      | 计方案就会变得越好、 |
|                      |                      |                      |
|                      |                      | -   信息             |
|                      |                      | 隐藏是个非常有价值的 |
|                      |                      | 概念。通过询问"我应  |
|                      |                      | 该隐藏什么？"能够解  |
|                      |                      | 决很多困难的设计问题 |
+----------------------+----------------------+----------------------+
| 6可以工作的类        |                      | -   类               |
|                      |                      | 的接口应提供一致的抽 |
|                      |                      | 象。很多问题都是由于 |
|                      |                      | 违背该原则而引起的。 |
|                      |                      |                      |
|                      |                      | -   类的接口应隐     |
|                      |                      | 藏一些信息------如某 |
|                      |                      | 个系统接口、某项设计 |
|                      |                      | 决策、或一些实现细节 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 包含往往比继承更为可 |
|                      |                      | 取------除非你要对is |
|                      |                      |     > a 的关系建模   |
|                      |                      |                      |
|                      |                      | -   继承             |
|                      |                      | 是一种有用的工具，但 |
|                      |                      | 它却会增加复杂度，这 |
|                      |                      | 有违于软件的首要技术 |
|                      |                      | 使命------管理复杂度 |
|                      |                      |                      |
|                      |                      | -   类是管理复       |
|                      |                      | 杂度的首选工具。要在 |
|                      |                      | 设计类时给予足够的关 |
|                      |                      | 注，才能实现这一目标 |
+----------------------+----------------------+----------------------+
| 7高质量的子程序      |                      | -                    |
|                      |                      |   创建子程序最主要的 |
|                      |                      | 目的是提高程序的可管 |
|                      |                      | 理性，当然也有其他的 |
|                      |                      | 一些好的理由。其中， |
|                      |                      | 节省代码空间只是一个 |
|                      |                      | 次要的原因：提高可读 |
|                      |                      | 性、可靠性和可修改性 |
|                      |                      | 等原因都更重要一些'  |
|                      |                      |                      |
|                      |                      | -   有时候，把一     |
|                      |                      | 些简单的操作写成独立 |
|                      |                      | 的子程序也非常有价值 |
|                      |                      |                      |
|                      |                      | -   子程序可以按照其 |
|                      |                      | 内聚性分为很多类，而 |
|                      |                      | 你应该让大多数子程序 |
|                      |                      | 具有功能上的内聚性， |
|                      |                      | 这是最佳的一种内聚性 |
|                      |                      |                      |
|                      |                      | -   子程             |
|                      |                      | 序的名字是它的质量指 |
|                      |                      | 示器。如果名字糟糕但 |
|                      |                      | 恰如其分，那就说明这 |
|                      |                      | 个子程序设计得很差劲 |
|                      |                      | 。如果名字糟糕而且又 |
|                      |                      | 不准确，那么它就反映 |
|                      |                      | 不出程序是干什么的。 |
|                      |                      | 不管怎样，糟糕的名字 |
|                      |                      | 意味着程序需要修改。 |
|                      |                      |                      |
|                      |                      | -   只有在某个子程   |
|                      |                      | 序的主要目的是返回由 |
|                      |                      | 其名字所描述的特定结 |
|                      |                      | 果时，才应该使用函数 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 细心的程序员会非常谨 |
|                      |                      | 慎的使用宏，而且只在 |
|                      |                      | 万不得已的时候才用。 |
+----------------------+----------------------+----------------------+
| 8防御式编程          |                      | -   最               |
|                      |                      | 终产品代码中对错误的 |
|                      |                      | 处理方式要比"垃圾进  |
|                      |                      | ，垃圾出"复杂的多。  |
|                      |                      |                      |
|                      |                      | -   防御式编程技术可 |
|                      |                      | 以让错误更容易发现、 |
|                      |                      | 更容易修改，并减少错 |
|                      |                      | 误对产品代码的破坏。 |
|                      |                      |                      |
|                      |                      | -   断言可           |
|                      |                      | 以帮助人尽早发现错误 |
|                      |                      | ，尤其是在大型系统和 |
|                      |                      | 高可靠性的系统中，以 |
|                      |                      | 及快速变化的代码中。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 关于如何处理错误输入 |
|                      |                      | 的决策是一项关键的错 |
|                      |                      | 误处理决策，也是一项 |
|                      |                      | 关键的高层设计决策。 |
|                      |                      |                      |
|                      |                      | -   异常提供了       |
|                      |                      | 一种与代码正常流程角 |
|                      |                      | 度不同错误处理手段。 |
|                      |                      | **如果留心使用异常， |
|                      |                      | 它可以称为程序员们知 |
|                      |                      | 识工具箱中的一项有益 |
|                      |                      | 补充**，同时也应该在 |
|                      |                      | 异常和其他错误处理手 |
|                      |                      | 段之间进行权衡比较。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 针对产品代码的限制并 |
|                      |                      | 不适用于开发中的软件 |
|                      |                      | 。你可以利用这一优势 |
|                      |                      | 在开发中添加有助于更 |
|                      |                      | 快地排查错误的代码。 |
+----------------------+----------------------+----------------------+
| 9伪代码编程过程      |                      | -   创               |
|                      |                      | 建类和子程序通常都是 |
|                      |                      | 一个**迭代**的过程。 |
|                      |                      | 在创建子程序的过程中 |
|                      |                      | 获得的认识常常会**反 |
|                      |                      | 过来**影响类的设计。 |
|                      |                      |                      |
|                      |                      | -   编写好的         |
|                      |                      | 伪代码需要使用易懂的 |
|                      |                      | 英语/自然语言/人话， |
|                      |                      | 要避免使用特定编程语 |
|                      |                      | 言中才有的特性，同时 |
|                      |                      | 要在意图的层面上写伪 |
|                      |                      | 代码（即描述该做什么 |
|                      |                      | ，而不是要怎么做）。 |
|                      |                      |                      |
|                      |                      | -   伪代码编         |
|                      |                      | 程过程是一个行之有效 |
|                      |                      | 的做详细设计的工具， |
|                      |                      | 它同时让编码工作更容 |
|                      |                      | 易。伪代码会直接转化 |
|                      |                      | 为注释，从而确保了注 |
|                      |                      | 释的准确性与实用性。 |
|                      |                      |                      |
|                      |                      | -   不要             |
|                      |                      | 只停留在你所想到的第 |
|                      |                      | 一个设计方案上。反复 |
|                      |                      | 使用伪代码作出多种方 |
|                      |                      | 案，然后选出其中最佳 |
|                      |                      | 的一种方案开始编码。 |
|                      |                      |                      |
|                      |                      | 每一步完成后都       |
|                      |                      | 要检查你的工作成果， |
|                      |                      | 还要鼓励其他人帮你来 |
|                      |                      | 检查。这样你就会在投 |
|                      |                      | 入精力最少的时候，用 |
|                      |                      | 最低的成本发现错误。 |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | 第3部分 **变量**     |                      |
+----------------------+----------------------+----------------------+
| 10使用变量的一般事项 |                      | -   数据             |
|                      |                      | 初始化过程很容易出错 |
|                      |                      | ，使用上面初始化方法 |
|                      |                      | 来避免由于非预期的初 |
|                      |                      | 始化值而造成的错误。 |
|                      |                      |                      |
|                      |                      | -   最小化           |
|                      |                      | 每个变量的作用域。把 |
|                      |                      | 同一变量的引用点集中 |
|                      |                      | 在一起。把变量限定在 |
|                      |                      | 子程序或类的范围之内 |
|                      |                      | 。避免使用全局数据。 |
|                      |                      |                      |
|                      |                      | -   把使用相同变量的 |
|                      |                      | 语句尽可能集中在一起 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 早起绑定会减低灵活性 |
|                      |                      | ，但有助于减小复杂度 |
|                      |                      | 。晚期绑定可以增加灵 |
|                      |                      | 活性，同时增加复杂度 |
|                      |                      |                      |
|                      |                      | -   **把每           |
|                      |                      | 个变量用于唯一用途** |
+----------------------+----------------------+----------------------+
| 11变量名的力量       |                      | -   好               |
|                      |                      | 的变量名是提高程序可 |
|                      |                      | 读性的一项关键要素。 |
|                      |                      | 对特殊种类的变量，比 |
|                      |                      | 如循环下表和状态变量 |
|                      |                      | ，需要加以特殊的考虑 |
|                      |                      |                      |
|                      |                      | -   名字             |
|                      |                      | 要尽可能的具体。那些 |
|                      |                      | 台模糊或者太通用以至 |
|                      |                      | 于能够用于多种目的的 |
|                      |                      | 名字通常都是很不好的 |
|                      |                      |                      |
|                      |                      | -   命名规           |
|                      |                      | 则应该能够区分局部数 |
|                      |                      | 据、类数据和全局数据 |
|                      |                      | 。他们还应该可以区分 |
|                      |                      | 类型名、具名常量、枚 |
|                      |                      | 举类型名字和变量名。 |
|                      |                      |                      |
|                      |                      | -   无论哪种类       |
|                      |                      | 型项目，你都应该采用 |
|                      |                      | 某种变量命名规则。你 |
|                      |                      | 所采用的规则的种类取 |
|                      |                      | 决于你的程序的规模， |
|                      |                      | 以及项目成员的人数。 |
|                      |                      |                      |
|                      |                      | -   现代             |
|                      |                      | 编程语言很少需要用到 |
|                      |                      | 缩写。如果你真的要是 |
|                      |                      | 用缩写，请使用**项目 |
|                      |                      | 缩写词典**或者**标准 |
|                      |                      | 前缀**来帮助理解缩写 |
|                      |                      |                      |
|                      |                      | -   **代             |
|                      |                      | 码阅读的次数远远多于 |
|                      |                      | 编写的次数。确保你所 |
|                      |                      | 取得名字更侧重于阅读 |
|                      |                      | 方便而不是编写方便** |
+----------------------+----------------------+----------------------+
| 12基本数据类型       |                      | -   使用特定的       |
|                      |                      | 数据类型就意味着要记 |
|                      |                      | 住适用于各个类型的很 |
|                      |                      | 多独立的原则。用本章 |
|                      |                      | 的核对表来确认你已经 |
|                      |                      | 对常见问题做了考虑。 |
|                      |                      |                      |
|                      |                      | -   如果你的语言支   |
|                      |                      | 持，创建自定义类型会 |
|                      |                      | 使得你的程序更容易修 |
|                      |                      | 改，并更具有自描述性 |
|                      |                      |                      |
|                      |                      | -   **当你           |
|                      |                      | 用typedef或者其等价  |
|                      |                      | 方式创建了一个简单类 |
|                      |                      | 型的时候，考虑是否更 |
|                      |                      | 应该创建一个新的类** |
+----------------------+----------------------+----------------------+
| 13不常见的数据类型   |                      | -   结构体可以使     |
|                      |                      | 得程序更简单、更容易 |
|                      |                      | 理解，以及更容易维护 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   每当你打算使用结构 |
|                      |                      | 体的时候，考虑采用类 |
|                      |                      | 是不是会工作的更好。 |
|                      |                      |                      |
|                      |                      | -   指针很容         |
|                      |                      | 易出错。用访问子程序 |
|                      |                      | 或类以及防御式编程实 |
|                      |                      | 践来保护自己的代码。 |
|                      |                      |                      |
|                      |                      | -   **               |
|                      |                      | 避免使用全局变量，不 |
|                      |                      | 只是因为它们危险，还 |
|                      |                      | 是因为你可以用其他更 |
|                      |                      | 好的方法取代它们。** |
|                      |                      |                      |
|                      |                      | -   如果你           |
|                      |                      | 不得不使用全局变量， |
|                      |                      | 那么就通过访问子程序 |
|                      |                      | 来使用它。访问器子程 |
|                      |                      | 序能为你带来全局变量 |
|                      |                      | 所能带来的一切优点， |
|                      |                      | 还有一些额外的好处。 |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第4部分 语句       |                      |
|                      | statement**          |                      |
+----------------------+----------------------+----------------------+
| 14组织直线型代码     |                      | -   组织直线         |
|                      |                      | 型代码的最主要原则是 |
|                      |                      | 按照依赖关系进行排列 |
|                      |                      |                      |
|                      |                      | -   可               |
|                      |                      | 以用好的子程序名、参 |
|                      |                      | 数列表、注释以及---- |
|                      |                      | --如果代码足够重要-- |
|                      |                      | ----内务管理变量来让 |
|                      |                      | 依赖关系变得更明显。 |
|                      |                      |                      |
|                      |                      | -   如               |
|                      |                      | 果代码之间没有顺序依 |
|                      |                      | 赖关系，那就设法使相 |
|                      |                      | 关的语句尽可能接近。 |
+----------------------+----------------------+----------------------+
| 15使用条件语句       |                      | -   对于简单的i      |
|                      |                      | f-else语句，请注意if |
|                      |                      | 子句和else子句的顺序 |
|                      |                      | ，特别是用它来处理大 |
|                      |                      | 量错误的时候。要确认 |
|                      |                      | 正常的情况是清晰的。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   对于if-then-else语 |
|                      |                      | 句串和case语句，选择 |
|                      |                      | 一种最利于阅读的排序 |
|                      |                      |                      |
|                      |                      | -   为了捕           |
|                      |                      | 捉错误，可以使用cas  |
|                      |                      | e语句中的default子句 |
|                      |                      | （默认子句），或者使 |
|                      |                      | 用if-then-else语句串 |
|                      |                      | 中的最后那个else子句 |
|                      |                      |                      |
|                      |                      | -   各种控制         |
|                      |                      | 结构并不是生来平等的 |
|                      |                      | 。请为代码的每个部分 |
|                      |                      | 选用最合适的控制结构 |
|                      |                      |                      |
|                      |                      | \-\-\-\-\--》表驱动  |
+----------------------+----------------------+----------------------+
| 16控制循环           |                      | -   循环很复         |
|                      |                      | 杂，保持循环简单讲有 |
|                      |                      | 助于别人阅读你的代码 |
|                      |                      |                      |
|                      |                      | -   保               |
|                      |                      | 持循环简单的技巧包括 |
|                      |                      | ：避免使用怪异的循环 |
|                      |                      | 、减少嵌套层次、让入 |
|                      |                      | 口和出口一目了然，把 |
|                      |                      | 内务操作代码放在一起 |
|                      |                      |                      |
|                      |                      | -   循环下标         |
|                      |                      | 很容易被滥用。因此命 |
|                      |                      | 名要准确，并且要把它 |
|                      |                      | 们各自仅用于一个用途 |
|                      |                      |                      |
|                      |                      | -   仔               |
|                      |                      | 细地考虑循环，确认他 |
|                      |                      | 在每一种情况下都能运 |
|                      |                      | 行正常，并且在所有可 |
|                      |                      | 能的条件下都能退出。 |
+----------------------+----------------------+----------------------+
| 17不常见的控制结构   |                      | -   多               |
|                      |                      | 个return可以增强子程 |
|                      |                      | 序的可读性和可维护性 |
|                      |                      | ，同时可以避免产生很 |
|                      |                      | 深的嵌套逻辑。但使用 |
|                      |                      | 它的时候要多加小心。 |
|                      |                      |                      |
|                      |                      | -   递归能够很优雅的 |
|                      |                      | 解决一小部分问题。对 |
|                      |                      | 他的使用要倍加小心。 |
|                      |                      |                      |
|                      |                      | -   在少数           |
|                      |                      | 情况下，goto是编写可 |
|                      |                      | 读性和可维护性代码的 |
|                      |                      | 最佳方法。但这种情况 |
|                      |                      | 非常罕见。**除非万不 |
|                      |                      | 得已，不要使用goto** |
+----------------------+----------------------+----------------------+
| 18表驱动法           |                      | -   表提供了         |
| Table-Driven Methods |                      | 一种复杂的逻辑和继承 |
|                      |                      | 结构的替换方案。如果 |
|                      |                      | 你发现自己对某个应用 |
|                      |                      | 程序的逻辑或者继承树 |
|                      |                      | 关系感到困惑，那么问 |
|                      |                      | 问自己它是否可以通过 |
|                      |                      | 一个查询表来加以优化 |
|                      |                      |                      |
|                      |                      | -   使用表的两大关   |
|                      |                      | 键决策：1、如何访问  |
|                      |                      | 表；2、表中存放什么  |
|                      |                      |                      |
|                      |                      | \--》状态机          |
+----------------------+----------------------+----------------------+
| 19一般控制问题       |                      | -   使布尔表达       |
|                      |                      | 式简单可读，将非常有 |
|                      |                      | 助于提高你的代码质量 |
|                      |                      |                      |
|                      |                      | -   深层次的嵌套     |
|                      |                      | 使得子程序变得难以理 |
|                      |                      | 解。所幸的时，你可以 |
|                      |                      | 相对容易的避免这么做 |
|                      |                      |                      |
|                      |                      | -   结构化编程是一   |
|                      |                      | 种简单并且仍然适用的 |
|                      |                      | 思想：你可以通过把顺 |
|                      |                      | 序、选择和循环三者组 |
|                      |                      | 合起来而开发任何程序 |
|                      |                      |                      |
|                      |                      | -   将复             |
|                      |                      | 杂度降低到最低水平是 |
|                      |                      | 编写高质量代码的关键 |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第5 部分           |                      |
|                      | 代码改善**           |                      |
+----------------------+----------------------+----------------------+
| 20 软件质量描述      |                      | -   开发高质         |
|                      |                      | 量代码最终并没有要求 |
|                      |                      | 你付出更多，只是你需 |
|                      |                      | 要对资源进行重新分配 |
|                      |                      | ，以地梁的成本来防止 |
|                      |                      | 缺陷发生，从而**避免 |
|                      |                      | 代价高昂的修正工作** |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   并非所有的质量保证 |
|                      |                      | 目标都可以全部实现。 |
|                      |                      | 明确哪些目标是你希望 |
|                      |                      | 达到的，并就这些目标 |
|                      |                      | 和团队成员进行沟通。 |
|                      |                      |                      |
|                      |                      | -   没               |
|                      |                      | 有任何一种错误检测方 |
|                      |                      | 法能够解决全部问题， |
|                      |                      | 测试本身并不是排除错 |
|                      |                      | 误的最有效方法。成功 |
|                      |                      | 的质量保证计划应该使 |
|                      |                      | 用多种不同的技术来检 |
|                      |                      | 查各种不同类型的错误 |
|                      |                      |                      |
|                      |                      | -   在构建           |
|                      |                      | 期间应该使用一些有效 |
|                      |                      | 的质量保证技术，但在 |
|                      |                      | 这之前，一些具有同样 |
|                      |                      | 强大功能的质量保证技 |
|                      |                      | 术也是必不可少的。错 |
|                      |                      | 误发现的越早，它与其 |
|                      |                      | 他代码的纠缠就越少， |
|                      |                      | 由此造成的损失也越小 |
|                      |                      |                      |
|                      |                      | -   软件             |
|                      |                      | 领域的质量保证是面向 |
|                      |                      | 过程的。软件开发与制 |
|                      |                      | 造业一样，在这里并不 |
|                      |                      | 存在会影响最终产品的 |
|                      |                      | 重复阶段，因此，最终 |
|                      |                      | 产品的重量所受到开发 |
|                      |                      | 软件所用的过程控制。 |
+----------------------+----------------------+----------------------+
| 21协同构建           |                      | -   协同开发实践     |
|                      |                      | 往往能比测试发现更多 |
|                      |                      | 的缺陷，并且更有效率 |
|                      |                      |                      |
|                      |                      | -   协               |
|                      |                      | 同开发实践所发现错误 |
|                      |                      | 的类型通常跟测试所发 |
|                      |                      | 现的不同，这意味着你 |
|                      |                      | 需要同时使用详查和测 |
|                      |                      | 试来保证你软件的质量 |
|                      |                      |                      |
|                      |                      | -   正式             |
|                      |                      | 检查通过运用核对表、 |
|                      |                      | 准备工作、明确定义角 |
|                      |                      | 色以及对方法的持续改 |
|                      |                      | 善，将缺陷侦测的相率 |
|                      |                      | 提升至最高。他往往能 |
|                      |                      | 比走查发现更多的缺陷 |
|                      |                      |                      |
|                      |                      | -   通常，结对编程   |
|                      |                      | 拥有和详查相同的成本 |
|                      |                      | ，并能产生质量相当的 |
|                      |                      | 代码。当需要缩短开发 |
|                      |                      | 周期的时候，结对编程 |
|                      |                      | 就非常有价值。相对于 |
|                      |                      | 单独工作而说，有些开 |
|                      |                      | 发人员更喜欢结对工作 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   正式检查可以应用在 |
|                      |                      | 除代码之外的很多工作 |
|                      |                      | 成果上，例如需求、设 |
|                      |                      | 计以及测试用例等等。 |
|                      |                      |                      |
|                      |                      | -   走查和代码阅读是 |
|                      |                      | 详查的替代方案。代码 |
|                      |                      | 阅读更富有弹性，能有 |
|                      |                      | 效地利用每个人的时间 |
+----------------------+----------------------+----------------------+
| 22开发者测试         |                      | -                    |
|                      |                      |   开发人员测试是完整 |
|                      |                      | 测试策略的一个关键部 |
|                      |                      | 分。独立测试也很重要 |
|                      |                      |                      |
|                      |                      | -   同编             |
|                      |                      | 码之后写测试用例相比 |
|                      |                      | 较，编码开始之前编写 |
|                      |                      | 测试用例,工作量和花  |
|                      |                      | 费的时间差不多，但是 |
|                      |                      | 后者可以缩短缺陷-侦  |
|                      |                      | 测-调试-修正这一周期 |
|                      |                      |                      |
|                      |                      | -   及时             |
|                      |                      | 考虑到了各种可用的测 |
|                      |                      | 试手段，测试仍然只是 |
|                      |                      | 良好软件质量计划的一 |
|                      |                      | 部分。高质量的开发方 |
|                      |                      | 法至少和测试一样重要 |
|                      |                      | ，这包括尽可能减少需 |
|                      |                      | 求和设计阶段的缺陷。 |
|                      |                      | 在检测错误方面，协同 |
|                      |                      | 开发的成效至少与测试 |
|                      |                      | 相当。这些方法所检测 |
|                      |                      | 错误的类型也各不相同 |
|                      |                      |                      |
|                      |                      | -   你可以           |
|                      |                      | 根据各种不同的思路来 |
|                      |                      | 产生很多测试用例，这 |
|                      |                      | 些思路包括基础测试、 |
|                      |                      | 数据流分析、便捷分析 |
|                      |                      | 、错误数据类型以及正 |
|                      |                      | 确数据类型等。你还可 |
|                      |                      | 以通过猜测错误的方式 |
|                      |                      | 得到更多的测试用例。 |
|                      |                      |                      |
|                      |                      | -   错               |
|                      |                      | 误往往集中在少数几个 |
|                      |                      | 容易出错的类和子程序 |
|                      |                      | 上。找出这部分代码， |
|                      |                      | 重新设计和编写他们。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   **测试数据本身出错 |
|                      |                      | 的密度往往比被测试的 |
|                      |                      | 代码还高**。查找这种 |
|                      |                      | 错误完全是浪费时间， |
|                      |                      | 又不能对代码有所改善 |
|                      |                      | ，因此测试数据里面的 |
|                      |                      | 错误更加让人烦恼。要 |
|                      |                      | 像修改代码一样小心地 |
|                      |                      | 开发测试用例，这样才 |
|                      |                      | 能避免产生这种问题。 |
|                      |                      |                      |
|                      |                      | -   自动化测试       |
|                      |                      | 总体来说是有用的，也 |
|                      |                      | 是进行回归测试的基础 |
|                      |                      |                      |
|                      |                      | -   从长远           |
|                      |                      | 来看，改善测试过程的 |
|                      |                      | 最好办法就是将其规范 |
|                      |                      | 化，并对其进行评估， |
|                      |                      | 然后用从评估中获得的 |
|                      |                      | 经验来改善这个过程。 |
+----------------------+----------------------+----------------------+
| 23调试               |                      | -   调试同整个软件   |
|                      |                      | 开发的成败息息相关。 |
|                      |                      | 最好的解决之道是使用 |
|                      |                      | 科学的方法来避免缺陷 |
|                      |                      | 的产生。然而，花点时 |
|                      |                      | 间来提高自己的调试技 |
|                      |                      | 能还是很划算的，因为 |
|                      |                      | 优秀和拙劣的调试表现 |
|                      |                      | 之间的差距至少是10:1 |
|                      |                      |                      |
|                      |                      | -   要想成功，系统化 |
|                      |                      | 的查找和改正错误的方 |
|                      |                      | 法直观重要。要专注于 |
|                      |                      | 你的调试工作，让每一 |
|                      |                      | 次测试都能让你朝着正 |
|                      |                      | 确的方向前进一步。要 |
|                      |                      | 是用科学的调试方法。 |
|                      |                      |                      |
|                      |                      | -   在动手解决       |
|                      |                      | 问题之前，要理解问题 |
|                      |                      | 的根本。胡乱猜测错误 |
|                      |                      | 的来源和随机修改将会 |
|                      |                      | 让你的程序陷入比刚开 |
|                      |                      | 始调试时更糟糕的境地 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 将编译器警告级别设置 |
|                      |                      | 为最严格，把警告信息 |
|                      |                      | 所报告的错误都改正。 |
|                      |                      | 如果你忽略了明显的错 |
|                      |                      | 误，那么要改正那些微 |
|                      |                      | 妙的错误就会非常麻烦 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 调试工具对软件开发而 |
|                      |                      | 言是强有力的支持手段 |
|                      |                      | 。找出这些工具并加以 |
|                      |                      | 应用，当然，请记得在 |
|                      |                      | 调试的时候开动脑筋。 |
+----------------------+----------------------+----------------------+
| 24重构               |                      | -   修改是程序医     |
|                      |                      | 生都要面对的事情，不 |
|                      |                      | 仅包括最初的开发阶段 |
|                      |                      | ，还包括首次发布之后 |
|                      |                      |                      |
|                      |                      | -   在修改中软       |
|                      |                      | 件的质量要么改进，要 |
|                      |                      | 么恶化。软件烟花的首 |
|                      |                      | 要法则就是代码演化应 |
|                      |                      | 当提升程序的内在质量 |
|                      |                      |                      |
|                      |                      | -   重构成           |
|                      |                      | 功之关键在于程序员应 |
|                      |                      | 该学会**关注那些标志 |
|                      |                      | 着代码需要重构的众多 |
|                      |                      | 的警告或"代码臭味"** |
|                      |                      |                      |
|                      |                      | -   重构成功的另一   |
|                      |                      | 个要素是程序员应当掌 |
|                      |                      | 握大量特定的重构方法 |
|                      |                      |                      |
|                      |                      | -   重构成功的最后要 |
|                      |                      | 点在于要有安全重构的 |
|                      |                      | 策略。一些重构方法会 |
|                      |                      | 比其他重构方法要好。 |
|                      |                      |                      |
|                      |                      | -   开发阶段的重     |
|                      |                      | 构时提升程序质量的最 |
|                      |                      | 佳时机，因为你可以立 |
|                      |                      | 刻让刚产生的改变梦想 |
|                      |                      | 编程现实。请珍惜这些 |
|                      |                      | 开发阶段的天赐良机。 |
|                      |                      |                      |
|                      |                      | \--》《重构，        |
|                      |                      | 改善既有代码的设计》 |
+----------------------+----------------------+----------------------+
| 25代码调整策略       |                      | -   性能             |
|                      |                      | 只是软件整体质量的一 |
|                      |                      | 个方面，通常不是最重 |
|                      |                      | 要的。精细的代码调整 |
|                      |                      | 也只是实现整体性能的 |
|                      |                      | 一种方法，通常也不是 |
|                      |                      | 决定性的。相对于代码 |
|                      |                      | 本身的效率而言，程序 |
|                      |                      | 的架构、细节设计以及 |
|                      |                      | 数据结构和算法选对程 |
|                      |                      | 序的运行速度和资源占 |
|                      |                      | 用的影响通常会更人。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 定量测量是实现性能最 |
|                      |                      | 优化的关键。定量测最 |
|                      |                      | 需要找出能真正决定程 |
|                      |                      | 序性能的部分，在修改 |
|                      |                      | 之后，应当通过重复测 |
|                      |                      | 量来明确修改是提高还 |
|                      |                      | 是降低了软件的性能。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 绝大多数的程序都有那 |
|                      |                      | 么一小部分代码耗费了 |
|                      |                      | 绝大部分的运行时间。 |
|                      |                      | 如果没有测量，你不会 |
|                      |                      | 知道是哪一部分代码。 |
|                      |                      |                      |
|                      |                      | -   代码调整需       |
|                      |                      | 要反复尝试，这样才能 |
|                      |                      | 获得理想的性能提髙。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      | 为性能优化工作做好准 |
|                      |                      | 备的最佳方式就是在最 |
|                      |                      | 初阶段编写清晰的代码 |
|                      |                      | ，从而使代码在后续丄 |
|                      |                      | 作中易于理解和修改。 |
+----------------------+----------------------+----------------------+
| 26代码调整技术       |                      | -   优化结           |
|                      |                      | 果在不同的语言、编译 |
|                      |                      | 器和环境下有很大差异 |
|                      |                      | 。如果没有对每一次的 |
|                      |                      | 优化进行测量，你将无 |
|                      |                      | 法判断优化到底是帮助 |
|                      |                      | 还是损害了这个程序。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   第一次优化通常不会 |
|                      |                      | 是最好的。即使找到了 |
|                      |                      | 效果很不错的，也不要 |
|                      |                      | 停下扩大战果的步伐。 |
|                      |                      |                      |
|                      |                      | -   代码调整这一话   |
|                      |                      | 题有点类似于核能，.  |
|                      |                      | 富有争议，甚至会让人 |
|                      |                      | 冲动。一些人认为代码 |
|                      |                      | 调整损害了代码可读性 |
|                      |                      | 和可维护性，他们绝对 |
|                      |                      | 会将其弃之不用。其他 |
|                      |                      | 人则认为只要有适当的 |
|                      |                      | 安全保陣，代码调整对 |
|                      |                      | 程序是有益的。如果你 |
|                      |                      | 决定使用上述的调整方 |
|                      |                      | 法，请务必谨慎行事。 |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第6 部分系统考虑** |                      |
+----------------------+----------------------+----------------------+
| 27                   |                      | -   随着项目规       |
| 程序规模对构建的影响 |                      | 模的扩大，交流需要加 |
|                      |                      | 以支持◊大多数方法论  |
|                      |                      | 的关键点都在于减少交 |
|                      |                      | 流中的问题，而一项方 |
|                      |                      | 法论的存亡关键也应取 |
|                      |                      | 决于它能否促进交流。 |
|                      |                      |                      |
|                      |                      | -   在其他条件都     |
|                      |                      | 相等的时候，大项目的 |
|                      |                      | 生产率会低于小项目。 |
|                      |                      |                      |
|                      |                      | -   在               |
|                      |                      | 其他条件都相等的时候 |
|                      |                      | ，大项目的每千行代码 |
|                      |                      | 错误率会高于小项目。 |
|                      |                      |                      |
|                      |                      | -   在小项目里的     |
|                      |                      | 一些看起来"理当如此  |
|                      |                      | "的活动在大项目中必  |
|                      |                      | 须仔细地计划。随着项 |
|                      |                      | 目规模扩大，构建活动 |
|                      |                      | 的主导地位逐渐降低。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   放大轻量级的方法论 |
|                      |                      | 要好于缩小重量级的方 |
|                      |                      | 法论。最有效的办法是 |
|                      |                      | 使用"适量级"方法论。 |
+----------------------+----------------------+----------------------+
| 28管理构建           |                      | -   好的             |
|                      |                      | 编码实践可以通过"贯  |
|                      |                      | 彻标准"或者"使用更为 |
|                      |                      | 灵活的方法"来达到。  |
|                      |                      |                      |
|                      |                      | -   配置管理，如     |
|                      |                      | 果应用得当，会使程序 |
|                      |                      | 员的工作变得更加轻松 |
|                      |                      | 。特别包括变更控制。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   好的软件评估是一项 |
|                      |                      | 重大挑战。成功的关键 |
|                      |                      | 包括采用多种方法、随 |
|                      |                      | 着项目的开展而修缮评 |
|                      |                      | 估结果，以及很好地利 |
|                      |                      | 用数据来创建评估等。 |
|                      |                      |                      |
|                      |                      | -   度量是           |
|                      |                      | 构建管理成功的关键。 |
|                      |                      | 你可以采取措施度量项 |
|                      |                      | 目的任何方面，而这要 |
|                      |                      | 比根本不度量好得多。 |
|                      |                      | 准确的度量是制定准确 |
|                      |                      | 的进度表、质t控制和  |
|                      |                      | 改进开发过程的关键。 |
|                      |                      |                      |
|                      |                      | -   程序员和管理人员 |
|                      |                      | 都是人，在把他们当人 |
|                      |                      | 看的时候工作得最好。 |
+----------------------+----------------------+----------------------+
| 29集成               |                      | -   构               |
|                      |                      | 建的先后次序和集成的 |
|                      |                      | 步骤会影响设计、编码 |
|                      |                      | 、测试各类的顺序。一 |
|                      |                      | 个经过充分思考的集成 |
|                      |                      | 顺序能减少测试的工作 |
|                      |                      | 量，并使调试变容易。 |
|                      |                      |                      |
|                      |                      | -   增量集成有若干变 |
|                      |                      | 型，而且一一一除非项 |
|                      |                      | 目是微不足道的一．一 |
|                      |                      | 任何一种形式的增量集 |
|                      |                      | 成都比阶段式集成好。 |
|                      |                      |                      |
|                      |                      | -   针对每个特定的   |
|                      |                      | 项目，最佳的集成步骤 |
|                      |                      | 通常是自顶向下、自底 |
|                      |                      | 向上、风险导向及其他 |
|                      |                      | 集成方法的某种组合。 |
|                      |                      | 不型集成和直分块集成 |
|                      |                      | 通常都能工作得很好。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |   dailybuild能减少集 |
|                      |                      | 成的问题，提升开发人 |
|                      |                      | 员的士气，并提供非常 |
|                      |                      | 有用的项目管理信息。 |
+----------------------+----------------------+----------------------+
| 30编程工具           |                      | -   程序员           |
|                      |                      | 有时会在长达数年的时 |
|                      |                      | 间里忽视某些最强大的 |
|                      |                      | 工具，之后才发现并使 |
|                      |                      | 用之。好的工具能让你 |
|                      |                      | 的日子过得安逸得多。 |
|                      |                      |                      |
|                      |                      | -   下               |
|                      |                      | 面这些工具己经可用了 |
|                      |                      | ：编辑、分析代码质量 |
|                      |                      | 、重构、版本控制、除 |
|                      |                      | 错、测试、代码调整。 |
|                      |                      |                      |
|                      |                      | -   你能打造许       |
|                      |                      | 多自己用的专用工具。 |
|                      |                      |                      |
|                      |                      | 好的工               |
|                      |                      | 具能减少软件开发中最 |
|                      |                      | 单调乏味的工作的量， |
|                      |                      | 但它不能消除对"编程  |
|                      |                      | "的需要，虽然它会持  |
|                      |                      | 续地重塑"编程"的含义 |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第7 部分           |                      |
|                      | 软件工艺**           |                      |
+----------------------+----------------------+----------------------+
| 31布局和风格         |                      | -   可视化布         |
|                      |                      | 局的首要任务是指明代 |
|                      |                      | 码的逻辑组织。评估该 |
|                      |                      | 任务是否实现的指标包 |
|                      |                      | 括准确性、一致性、易 |
|                      |                      | 读性和易维护性。外表 |
|                      |                      | 悦目比起其他指标是最 |
|                      |                      | 不重要的。然而，如果 |
|                      |                      | 其他指标都达到了，代 |
|                      |                      | 码又质量好，那么布局 |
|                      |                      | 效果看上去也会不错。 |
|                      |                      |                      |
|                      |                      | -                    |
|                      |                      |  VisualBasic具有纯代 |
|                      |                      | 码块风格，而Java的传 |
|                      |                      | 统做法就是使用纯块风 |
|                      |                      | 格，所以若用这些语言 |
|                      |                      | 编程，就请使用纯代码 |
|                      |                      | 块风格。C++中，模拟  |
|                      |                      | 纯代码块或者begin-e  |
|                      |                      | nd块边界都行之有效。 |
|                      |                      |                      |
|                      |                      | -   结构化代码有     |
|                      |                      | 其自身目的。始终如一 |
|                      |                      | 地沿用某个习惯而少来 |
|                      |                      | 创新。不能持久的布局 |
|                      |                      | 规范只会损害可读性。 |
|                      |                      |                      |
|                      |                      | -   布局             |
|                      |                      | 的很多方面涉及信仰问 |
|                      |                      | 题。应试着将客观需要 |
|                      |                      | 和主观偏好区分开来。 |
|                      |                      |                      |
|                      |                      | -   定出明确         |
|                      |                      | 的指标，在此基础上冉 |
|                      |                      | 讨论风格参数的选择。 |
+----------------------+----------------------+----------------------+
| 32自说明代码         |                      | -   该不该           |
|                      |                      | 注释是个需要认真对待 |
|                      |                      | 的问题。差劲的注释只 |
|                      |                      | 会浪费时间，帮倒忙； |
|                      |                      | 好的注释才有价值。\  |
|                      |                      |     > +              |
|                      |                      | 源代码应当含有程序大 |
|                      |                      | 部分的关键信息。只要 |
|                      |                      | 程序依然在用，源代码 |
|                      |                      | 比其他资料都能保持更 |
|                      |                      | 新，故而将重要信息融 |
|                      |                      | 入代码是很有用处的。 |
|                      |                      |                      |
|                      |                      | -   好代码本身就是   |
|                      |                      | 最好的说明。如果代码 |
|                      |                      | 太糟，需要大量注释， |
|                      |                      | 应先试着改进代码，直 |
|                      |                      | 至无须过多注释为止。 |
|                      |                      |                      |
|                      |                      | -   注释应说出代码无 |
|                      |                      | 法说出的东西一一一例 |
|                      |                      | 如概述或用意等信息。 |
|                      |                      |                      |
|                      |                      | -   有的注           |
|                      |                      | 释风格需要许多重复性 |
|                      |                      | 劳动，应舍弃之，改用 |
|                      |                      | 易于维护的注释风格。 |
+----------------------+----------------------+----------------------+
| 33个人性格           |                      | -   人的个性对       |
|                      |                      | 其编程能力有直接影响 |
|                      |                      |                      |
|                      |                      | -   最有关           |
|                      |                      | 系的性格微：谦虚、求 |
|                      |                      | 知欲、诚实、创造性和 |
|                      |                      | 纪律、以及高明的偷懒 |
|                      |                      |                      |
|                      |                      | -   程序员高手       |
|                      |                      | 的性格与田飞无关而任 |
|                      |                      | 何事都与个人发展相关 |
|                      |                      |                      |
|                      |                      | -   出乎意料的是     |
|                      |                      | ，小聪明、经验、坚持 |
|                      |                      | 和疯狂既有助，也有害 |
|                      |                      |                      |
|                      |                      | -   很多程序员不愿   |
|                      |                      | 意主动吸收新知识和技 |
|                      |                      | 术，只依靠工作是偶尔 |
|                      |                      | 接触新的信息。如果你 |
|                      |                      | 能**抽出少量时间阅读 |
|                      |                      | 和学习编程知识，要不 |
|                      |                      | 了多久就能鹤立鸡群** |
|                      |                      |                      |
|                      |                      | -   好性格与培       |
|                      |                      | 养正确的习惯关系甚大 |
|                      |                      | 。要成为接触的程序员 |
|                      |                      | ，先要养成良好的习惯 |
|                      |                      | ，其它自然输掉渠成。 |
+----------------------+----------------------+----------------------+
| 34软件工艺的话题     |                      | -   **编程的主要目   |
|                      |                      | 的之一是管理复杂性** |
|                      |                      |                      |
|                      |                      | -   编程过程         |
|                      |                      | 对最终产品有深远影响 |
|                      |                      |                      |
|                      |                      | -   合作开发要求团队 |
|                      |                      | 成员之间进行广泛沟通 |
|                      |                      | ，甚于同计算机的交互 |
|                      |                      | ：而单人开发则是自我 |
|                      |                      | 交流，其次才是计算机 |
|                      |                      |                      |
|                      |                      | -   编程规范一旦滥   |
|                      |                      | 用，只会雪上加霜：使 |
|                      |                      | 用得当则能为开发环境 |
|                      |                      | 带来良好机制，有助于 |
|                      |                      | 管理复杂性和相互沟通 |
|                      |                      |                      |
|                      |                      | -   **编程应基于     |
|                      |                      | 问题域而非解决方案， |
|                      |                      | 这样便于复杂性管理** |
|                      |                      |                      |
|                      |                      | -   注               |
|                      |                      | 意警告信息，将其作为 |
|                      |                      | 编程的疑点，因为编程 |
|                      |                      | 几乎是纯粹的智力活动 |
|                      |                      |                      |
|                      |                      | -   开发时迭代次数   |
|                      |                      | 越多，产品的质量越好 |
|                      |                      |                      |
|                      |                      | -   墨守             |
|                      |                      | 成规的方法有悖于高质 |
|                      |                      | 量的软件开发。请将编 |
|                      |                      | 程工具箱中填满各种编 |
|                      |                      | 程工具，不断提高自己 |
|                      |                      | 挑选合适工具的能力。 |
+----------------------+----------------------+----------------------+

**3 程序员修炼之道**

  Tags                   Title             Notes key word
  ---------------------- ----------------- ----------------
                         1注重实效的哲学   
  我的源码让猫给吃了                       
  软件的熵                                 
  石头汤与煮青蛙                           
  足够好的软件                             
  你的知识资产                             
  交流                                     
                         2注重实效的途径   
  重复的危害                               
  正交性                                   
  可撤销性                                 
  曳光弹                                   
  原型与便笺                               
  领域语言                                 
  估算                                     
                         3基本工具         
  纯文本的威力                             
  shell游戏                                
  强力编辑                                 
  源码控制                                 
  调试                                     
  文本操纵                                 
                         4注重实效的偏执   
  按合约设计                               
  死程序不说谎                             
  断言式编程                               
  何时使用异常                             
                         5弯曲，或折断     
  解耦与得墨忒耳法则                       
  元程序设计                               
  时间耦合                                 
  它只是视图                               
  黑板                                     
                         6当你编码时       
  算法速率                                 
  重构                                     
  易于测试的代码                           
                         7在项目开始之前   
  需求坑                                   
  解开不可能解开的谜题                     
  等你准备好                               
  规范陷阱                                 
                         8注重实效的项目   
  注重实效的团队                           
  无处不在的自动化                         
  无情的测试                               
  全部都是写                               
                                           
                                           
                                           

**4 设计模式、设计模式的艺术**

+----------------------+----------------------+----------------------+
| Title                | Tag                  | Notes key word       |
+======================+======================+======================+
|                      | **1引言**            |                      |
+----------------------+----------------------+----------------------+
| 什么是设计模式       |                      |                      |
+----------------------+----------------------+----------------------+
| Smalltalk            |                      |                      |
| MVC中的设计模式      |                      |                      |
+----------------------+----------------------+----------------------+
| 描述设计模式         |                      |                      |
+----------------------+----------------------+----------------------+
| 设计模式的编目       |                      |                      |
+----------------------+----------------------+----------------------+
| 组织编目             |                      |                      |
+----------------------+----------------------+----------------------+
| 设计                 |                      | 寻找合适的对象       |
| 模式怎样解决设计问题 |                      |                      |
|                      |                      | 决定对象的粒度       |
|                      |                      |                      |
|                      |                      | 指定对象接口         |
|                      |                      |                      |
|                      |                      | 描述对象的实现       |
|                      |                      |                      |
|                      |                      | 运用复用机制         |
|                      |                      |                      |
|                      |                      | 关联                 |
|                      |                      | 运行时和编译时的结构 |
|                      |                      |                      |
|                      |                      | 设计应支持变化       |
+----------------------+----------------------+----------------------+
| 怎样选择设计模式     |                      |                      |
+----------------------+----------------------+----------------------+
| 怎样使用设计模式     |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **2                  |                      |
|                      | 实例研究：           |                      |
|                      | 设计一个文档编辑器** |                      |
+----------------------+----------------------+----------------------+
| 设计问题             |                      |                      |
+----------------------+----------------------+----------------------+
| 文档结构             |                      | 递归组合             |
|                      |                      |                      |
|                      |                      | 图元                 |
|                      |                      |                      |
|                      |                      | 组合模式             |
+----------------------+----------------------+----------------------+
| 格式化               |                      | 封装格式化算法       |
|                      |                      |                      |
|                      |                      | Com                  |
|                      |                      | positor和Composition |
|                      |                      |                      |
|                      |                      | 策略模式             |
+----------------------+----------------------+----------------------+
| 修饰用户界面         |                      | 透明围栏             |
|                      |                      |                      |
|                      |                      | Monoglyph            |
|                      |                      |                      |
|                      |                      | Decorator模式        |
+----------------------+----------------------+----------------------+
| 支持多种视感标准     |                      | 对象创建的抽象       |
|                      |                      |                      |
|                      |                      | 工厂类和产品类       |
|                      |                      |                      |
|                      |                      | Abstract Factory     |
|                      |                      | 模式                 |
+----------------------+----------------------+----------------------+
| 支持多种窗口系统     |                      | 是否可以使用Abstract |
|                      |                      | Factory模式          |
|                      |                      |                      |
|                      |                      | 封装实现依赖关系     |
|                      |                      |                      |
|                      |                      | Window和WindowImp    |
|                      |                      |                      |
|                      |                      | Bridge模式           |
+----------------------+----------------------+----------------------+
| 用户操作             |                      | 封装一个请求         |
|                      |                      |                      |
|                      |                      | Command类及其子类    |
|                      |                      |                      |
|                      |                      | 撤销和重做           |
|                      |                      |                      |
|                      |                      | 命令历史记录         |
|                      |                      |                      |
|                      |                      | Command模式          |
+----------------------+----------------------+----------------------+
| 拼写检查和断字处理   |                      | 访问分散的信息       |
|                      |                      |                      |
|                      |                      | 封装访问和遍历       |
|                      |                      |                      |
|                      |                      | Iterator类及其子类   |
|                      |                      |                      |
|                      |                      | Iterator模式         |
|                      |                      |                      |
|                      |                      | 遍                   |
|                      |                      | 历和遍历过程中的动作 |
|                      |                      |                      |
|                      |                      | 封装分析             |
|                      |                      |                      |
|                      |                      | Visitor类及其子类    |
|                      |                      |                      |
|                      |                      | Visitor模式          |
+----------------------+----------------------+----------------------+
|                      | **3创建型模式**      |                      |
+----------------------+----------------------+----------------------+
| Abstract             |                      |                      |
| Factory（抽象工厂    |                      |                      |
| ）---对象创建型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Builder（生成器      |                      |                      |
| ）---对象创建型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Factory              |                      |                      |
| Method（工厂方法     |                      |                      |
| ）---对象创建型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Prototype（原型      |                      |                      |
| ）---对象创建型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Singleton（单件      |                      |                      |
| ）---对象创建型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| 创建型模式的讨论     |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **4 结构型模式**     |                      |
+----------------------+----------------------+----------------------+
| Adapter（适配器）    |                      |                      |
| ---类对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Bridge（桥接         |                      |                      |
| ）---对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Composite（组合      |                      |                      |
| ）---对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Decorator（装饰      |                      |                      |
| ）---对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Facade（外观         |                      |                      |
| ）---对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Flyweight（享元      |                      |                      |
| ）---对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Proxy（代理          |                      |                      |
| ）---对象结构型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| 结构型模式的讨论     |                      | Adapter与Bridge      |
|                      |                      |                      |
|                      |                      | Composi              |
|                      |                      | te、Decorator与Proxy |
+----------------------+----------------------+----------------------+
|                      | **5 行为型模式**     |                      |
+----------------------+----------------------+----------------------+
| Chain of             |                      |                      |
| Re                   |                      |                      |
| sponsibility（职责链 |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Command（命令        |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Interpreter（解释    |                      |                      |
| 器）---类行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Iterator（迭代器     |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Mediator（中介者     |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Memento（备忘录      |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Observer（观察者     |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| State（状态          |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Strategy（策略       |                      |                      |
| ）---对象行为型模式  |                      |                      |
+----------------------+----------------------+----------------------+
| Template             |                      |                      |
| M                    |                      |                      |
| ethod（模板方法）--- |                      |                      |
| 类行为型模式         |                      |                      |
+----------------------+----------------------+----------------------+
| Visitor（访          |                      |                      |
| 问者）---对象行为型  |                      |                      |
| 模式                 |                      |                      |
+----------------------+----------------------+----------------------+
| 行为型模式的讨论     |                      | 封装变化             |
|                      |                      |                      |
|                      |                      | 对象作为参数         |
|                      |                      |                      |
|                      |                      | 通信                 |
|                      |                      | 应该被封装还是被分布 |
|                      |                      |                      |
|                      |                      | 对发送者和接收者解耦 |
+----------------------+----------------------+----------------------+
|                      | **6 结论**           |                      |
+----------------------+----------------------+----------------------+
| 设计模式将带来什么   |                      | 一套通用的设计词汇   |
|                      |                      |                      |
|                      |                      | 书写                 |
|                      |                      | 文档和学习的辅助手段 |
|                      |                      |                      |
|                      |                      | 现有方法的一种补充   |
|                      |                      |                      |
|                      |                      | 重构的目标           |
+----------------------+----------------------+----------------------+
| 模式界               |                      |                      |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **设计模式的艺术**   |                      |
+----------------------+----------------------+----------------------+
|                      | **第1部分 基         |                      |
|                      | 础知识**             |                      |
+----------------------+----------------------+----------------------+
|                      | **1                  |                      |
|                      | 从招式与内功谈       |                      |
|                      | 起---设计模式概述**  |                      |
+----------------------+----------------------+----------------------+
| 设计模式从何而来     |                      |                      |
+----------------------+----------------------+----------------------+
| 设计模式是什么       |                      |                      |
+----------------------+----------------------+----------------------+
| 设计模式有什么用     |                      |                      |
+----------------------+----------------------+----------------------+
| 个人观点             |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **2                  |                      |
|                      | 预备知识---UML类图   |                      |
|                      | 与面向对象设计原则** |                      |
+----------------------+----------------------+----------------------+
| UML概述              |                      |                      |
+----------------------+----------------------+----------------------+
| 类与类的UML图示      |                      |                      |
+----------------------+----------------------+----------------------+
| 类之间的关系         |                      |                      |
+----------------------+----------------------+----------------------+
| 面向对象设计原则概述 |                      |                      |
+----------------------+----------------------+----------------------+
| 单一职责原则         |                      |                      |
+----------------------+----------------------+----------------------+
| 开闭原则             |                      |                      |
+----------------------+----------------------+----------------------+
| 里氏代换原则         |                      |                      |
+----------------------+----------------------+----------------------+
| 依赖倒转原则         |                      |                      |
+----------------------+----------------------+----------------------+
| 接口隔离原则         |                      |                      |
+----------------------+----------------------+----------------------+
| 合成复用原则         |                      |                      |
+----------------------+----------------------+----------------------+
| 迪米特法则           |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第2部分            |                      |
|                      | 创建的               |                      |
|                      | 艺术---创建型模式**  |                      |
+----------------------+----------------------+----------------------+
|                      | **3                  |                      |
|                      | 确保对象的唯         |                      |
|                      | 一性------单例模式** |                      |
+----------------------+----------------------+----------------------+
| 单例模式的动机       |                      |                      |
+----------------------+----------------------+----------------------+
| 单例模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 负载均衡器的设计     |                      |                      |
+----------------------+----------------------+----------------------+
| 饿汉式单             |                      |                      |
| 例与懒汉式单例的讨论 |                      |                      |
+----------------------+----------------------+----------------------+
| 一                   |                      |                      |
| 种更好的单例实现方法 |                      |                      |
+----------------------+----------------------+----------------------+
| 单例模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **4                  |                      |
|                      | 集中式工厂的实       |                      |
|                      | 现---简单工厂模式**  |                      |
+----------------------+----------------------+----------------------+
| 图表库的设计         |                      |                      |
+----------------------+----------------------+----------------------+
| 简单工厂模式概述     |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 方案的改进           |                      |                      |
+----------------------+----------------------+----------------------+
| 创建对象与使用对象   |                      |                      |
+----------------------+----------------------+----------------------+
| 简单工厂模式的简化   |                      |                      |
+----------------------+----------------------+----------------------+
| 简单工厂模式总结     |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **5                  |                      |
|                      | 多态工厂的实         |                      |
|                      | 现---工厂方法模式**  |                      |
+----------------------+----------------------+----------------------+
| 日志记录器的设计     |                      |                      |
+----------------------+----------------------+----------------------+
| 工厂方法模式概述     |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 反射与配置文件       |                      |                      |
+----------------------+----------------------+----------------------+
| 重载的工厂方法       |                      |                      |
+----------------------+----------------------+----------------------+
| 工厂方法的隐藏       |                      |                      |
+----------------------+----------------------+----------------------+
| 工厂方法模式总结     |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **6                  |                      |
|                      | 产品族的创           |                      |
|                      | 建---抽象工厂模式**  |                      |
+----------------------+----------------------+----------------------+
| 界面皮肤库的初始设计 |                      |                      |
+----------------------+----------------------+----------------------+
| 产品等级结构与产品族 |                      |                      |
+----------------------+----------------------+----------------------+
| 抽象工厂模式概述     |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 开闭原则的倾斜性     |                      |                      |
+----------------------+----------------------+----------------------+
| 抽象工厂模式总结     |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **7                  |                      |
|                      | 对象                 |                      |
|                      | 的克隆---原型模式**  |                      |
+----------------------+----------------------+----------------------+
| 大同小异的工作周报   |                      |                      |
+----------------------+----------------------+----------------------+
| 原型模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 带附件的周报         |                      |                      |
+----------------------+----------------------+----------------------+
| 原                   |                      |                      |
| 型管理器的引入和实现 |                      |                      |
+----------------------+----------------------+----------------------+
| 原型模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **8复杂对象的组装与  |                      |
|                      | 创建---建造者模式**  |                      |
+----------------------+----------------------+----------------------+
| 游戏角色设计         |                      |                      |
+----------------------+----------------------+----------------------+
| 建造者模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 关于                 |                      |                      |
| Director的进一步讨论 |                      |                      |
+----------------------+----------------------+----------------------+
| 建造者模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第3部分组合的      |                      |
|                      | 艺术---结构型模式**  |                      |
+----------------------+----------------------+----------------------+
|                      | **9不兼容结构的      |                      |
|                      | 协调---适配器模式**  |                      |
+----------------------+----------------------+----------------------+
| 没有源码的算法库     |                      |                      |
+----------------------+----------------------+----------------------+
| 适配器模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 类适配器模式         |                      |                      |
+----------------------+----------------------+----------------------+
| 双向适配器模式       |                      |                      |
+----------------------+----------------------+----------------------+
| 缺省适配器模式       |                      |                      |
+----------------------+----------------------+----------------------+
| 适配器模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **10                 |                      |
|                      | 处理多维             |                      |
|                      | 度变化---桥接模式**  |                      |
+----------------------+----------------------+----------------------+
| 跨平台图像浏览系统   |                      |                      |
+----------------------+----------------------+----------------------+
| 桥接模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 适配器               |                      |                      |
| 模式与桥接模式的联用 |                      |                      |
+----------------------+----------------------+----------------------+
| 桥接模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **11                 |                      |
|                      | 树形结构             |                      |
|                      | 的处理---组合模式**  |                      |
+----------------------+----------------------+----------------------+
| 设                   |                      |                      |
| 计杀毒软件的框架结构 |                      |                      |
+----------------------+----------------------+----------------------+
| 组合模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 透明组               |                      |                      |
| 合模式与安全组合模式 |                      |                      |
+----------------------+----------------------+----------------------+
| Sunny公司组织结构    |                      |                      |
+----------------------+----------------------+----------------------+
| 组合模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **12                 |                      |
|                      | 扩展系               |                      |
|                      | 统功能---装饰模式**  |                      |
+----------------------+----------------------+----------------------+
| 图形界面构件库的设计 |                      |                      |
+----------------------+----------------------+----------------------+
| 装饰模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 透明装饰             |                      |                      |
| 模式与半透明装饰模式 |                      |                      |
+----------------------+----------------------+----------------------+
| 装饰模式注意事项     |                      |                      |
+----------------------+----------------------+----------------------+
| 装饰模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **13                 |                      |
|                      | 提供统               |                      |
|                      | 一入口---外观模式**  |                      |
+----------------------+----------------------+----------------------+
| 文件加密模块的设计   |                      |                      |
+----------------------+----------------------+----------------------+
| 外观模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 抽象外观类的引入     |                      |                      |
+----------------------+----------------------+----------------------+
| 外观角色设计补充说明 |                      |                      |
+----------------------+----------------------+----------------------+
| 外观模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **14                 |                      |
|                      | 实现对象             |                      |
|                      | 的复用---享元模式**  |                      |
+----------------------+----------------------+----------------------+
| 围棋棋子的设计       |                      |                      |
+----------------------+----------------------+----------------------+
| 享元模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 带外部状态的解决方案 |                      |                      |
+----------------------+----------------------+----------------------+
| 单纯享               |                      |                      |
| 元模式和复合享元模式 |                      |                      |
+----------------------+----------------------+----------------------+
| 关                   |                      |                      |
| 于享元模式的几点补充 |                      |                      |
+----------------------+----------------------+----------------------+
| 享元模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **15对象的间         |                      |
|                      | 接访问---代理模式**  |                      |
+----------------------+----------------------+----------------------+
| 收费商               |                      |                      |
| 务信息查询系统的设计 |                      |                      |
+----------------------+----------------------+----------------------+
| 代理模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 远程代理             |                      |                      |
+----------------------+----------------------+----------------------+
| 虚拟代理             |                      |                      |
+----------------------+----------------------+----------------------+
| Java动态代理         |                      |                      |
+----------------------+----------------------+----------------------+
| 代理模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **第4部分            |                      |
|                      | 交互的               |                      |
|                      | 艺术---行为型模式**  |                      |
+----------------------+----------------------+----------------------+
|                      | **16                 |                      |
|                      | 请求的链式           |                      |
|                      | 处理---职责链模式**  |                      |
+----------------------+----------------------+----------------------+
| 采购单的分级审批     |                      |                      |
+----------------------+----------------------+----------------------+
| 职责链模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 纯与不纯的职责链模式 |                      |                      |
+----------------------+----------------------+----------------------+
| 职责链模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **17                 |                      |
|                      | 请求发送者与接收     |                      |
|                      | 者解耦---命令模式**  |                      |
+----------------------+----------------------+----------------------+
| 自定义功能键         |                      |                      |
+----------------------+----------------------+----------------------+
| 命令模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 命令队列的实现       |                      |                      |
+----------------------+----------------------+----------------------+
| 撤销操作的实现       |                      |                      |
+----------------------+----------------------+----------------------+
| 请求日志             |                      |                      |
+----------------------+----------------------+----------------------+
| 宏命令               |                      |                      |
+----------------------+----------------------+----------------------+
| 命令模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **18                 |                      |
|                      | 自定义语言的         |                      |
|                      | 实现---解释器模式**  |                      |
+----------------------+----------------------+----------------------+
| 机器人控制程序       |                      |                      |
+----------------------+----------------------+----------------------+
| 文法规则和抽象语法树 |                      |                      |
+----------------------+----------------------+----------------------+
| 解释器模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 再谈Context的作用    |                      |                      |
+----------------------+----------------------+----------------------+
| 解释器模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **19                 |                      |
|                      | 遍历聚合对象中的     |                      |
|                      | 元素---迭代器模式**  |                      |
+----------------------+----------------------+----------------------+
| 销售                 |                      |                      |
| 管理系统中数据的遍历 |                      |                      |
+----------------------+----------------------+----------------------+
| 迭代器模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 使用内部类实现迭代器 |                      |                      |
+----------------------+----------------------+----------------------+
| JDK内置迭代器        |                      |                      |
+----------------------+----------------------+----------------------+
| 迭代器模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **20                 |                      |
|                      | 协调多个对象之间的   |                      |
|                      | 交互---中介者模式**  |                      |
+----------------------+----------------------+----------------------+
| 客户信               |                      |                      |
| 息管理窗口的初始设计 |                      |                      |
+----------------------+----------------------+----------------------+
| 中介者模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 中介者与同事类的扩展 |                      |                      |
+----------------------+----------------------+----------------------+
| 中介者模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **21                 |                      |
|                      | 撤销功能的           |                      |
|                      | 实现---备忘录模式**  |                      |
+----------------------+----------------------+----------------------+
| 可悔棋的中国象棋     |                      |                      |
+----------------------+----------------------+----------------------+
| 备忘录模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 实现多次撤销         |                      |                      |
+----------------------+----------------------+----------------------+
| 再谈备忘录的封装     |                      |                      |
+----------------------+----------------------+----------------------+
| 备忘录模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **22                 |                      |
|                      | 对象间的             |                      |
|                      | 联动---观察者模式**  |                      |
+----------------------+----------------------+----------------------+
| 多                   |                      |                      |
| 人联机对战游戏的设计 |                      |                      |
+----------------------+----------------------+----------------------+
| 观察者模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| J                    |                      |                      |
| DK对观察者模式的支持 |                      |                      |
+----------------------+----------------------+----------------------+
| 观察                 |                      |                      |
| 者模式与Java事件处理 |                      |                      |
+----------------------+----------------------+----------------------+
| 观察者模式与MVC      |                      |                      |
+----------------------+----------------------+----------------------+
| 观察者模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **23                 |                      |
|                      | 对象状态及           |                      |
|                      | 其转换---状态模式**  |                      |
+----------------------+----------------------+----------------------+
| 银                   |                      |                      |
| 行系统中的账户类设计 |                      |                      |
+----------------------+----------------------+----------------------+
| 状态模式概述         |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 共享状态             |                      |                      |
+----------------------+----------------------+----------------------+
| 使                   |                      |                      |
| 用环境类实现状态转换 |                      |                      |
+----------------------+----------------------+----------------------+
| 状态模式总结         |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **24                 |                      |
|                      | 银行                 |                      |
|                      | 系统中的账户类设计** |                      |
+----------------------+----------------------+----------------------+
| 电状态               |                      |                      |
| 模式概述影票打折方案 |                      |                      |
+----------------------+----------------------+----------------------+
| 策完                 |                      |                      |
| 整解决方案略模式概述 |                      |                      |
+----------------------+----------------------+----------------------+
| 完共享状态整解决方案 |                      |                      |
+----------------------+----------------------+----------------------+
| 策使                 |                      |                      |
| 用环境类实现状态转换 |                      |                      |
| 略模式的两个典型应用 |                      |                      |
+----------------------+----------------------+----------------------+
| 策状                 |                      |                      |
| 态模式总结略模式总结 |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **25                 |                      |
|                      | 定义算法的框         |                      |
|                      | 架---模板方法模式**  |                      |
+----------------------+----------------------+----------------------+
| 银行利息计算模块     |                      |                      |
+----------------------+----------------------+----------------------+
| 模板方法模式概述     |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 钩子方法的使用       |                      |                      |
+----------------------+----------------------+----------------------+
| 模板方法模式总结     |                      |                      |
+----------------------+----------------------+----------------------+
|                      | **26                 |                      |
|                      | 操作复杂对象         |                      |
|                      | 结构---访问者模式**  |                      |
+----------------------+----------------------+----------------------+
| OA系统中员工数据汇总 |                      |                      |
+----------------------+----------------------+----------------------+
| 访问者模式概述       |                      |                      |
+----------------------+----------------------+----------------------+
| 完整解决方案         |                      |                      |
+----------------------+----------------------+----------------------+
| 访问                 |                      |                      |
| 者模式与组合模式联用 |                      |                      |
+----------------------+----------------------+----------------------+
| 访问者模式总结       |                      |                      |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
|                      |                      |                      |
+----------------------+----------------------+----------------------+
